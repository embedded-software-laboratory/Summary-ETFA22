@startuml
package "ahorn" {
    package "compiler" {
        class Compiler {
            + parse(std::string const & source_code) : std::unique_ptr<Program>
            + generateIntermediateRepresentation(const Program &program) : void
        }
        class IEC61131Lexer <<auto-generated>> {

        }
        class IEC61131Parser <<auto-generated>> {

        }
        abstract class IEC61131Visitor <<auto-generated>> {

        }
        class ParseTreeVisitor {

        }
        ' Dependencies
        Compiler -- IEC61131Lexer
        Compiler -- IEC61131Parser
        IEC61131Visitor <|-- ParseTreeVisitor
        Compiler -- ParseTreeVisitor
        note "The parser is automatically generated by ANTLR4 \n using the IEC61131.g4 grammar file." as N1
        N1 .. IEC61131Parser
        note "The parse tree visitor is a concrete visitor for \n the parse tree produced by ANTLR4 via IEC61131Parser." as N2
        N2 .. ParseTreeVisitor
    }
    ' All identifiers are names, but not all names are identifiers.
    abstract class Name {
        - _name : std::string const
        # explicit Name(std::string name)
        + getName() : std::string
        + getFullyQualifiedName() : std::string
    }
    package "type" {
        abstract class Type {
            # Type(std::string name)
        }
        class ElementaryType {
            + ElementaryType(Kind kind)
        }
        enum Kind {
            BOOL, SINT, INT, ...
        }
        abstract class DerivedType {
            # DerivedType(std::string name)
        }
        ' Dependencies
        ElementaryType *-- Kind
    }
    package "expression" {
        abstract class Expression {

        }
        ' Designates a location. All LValues are RValues.
        class LValue {

        }
        ' Access a variable referring to a memory location using a name.
        ' TODO: What about x[i] and x.y?
        ' _name, because the access can be a composition of identifiers such as x.y
        class VariableAccess {
            - _name : std::string const
            + VariableAccess(std::string name)
        }
        ' Dependencies
        LValue <|-- VariableAccess
        ' Value that can be stored in a location.
        class RValue {

        }
        ' Dependencies
        Expression <|-- RValue
        RValue <|-- LValue
        abstract class PrimaryExpression {

        }
        class UnaryExpression {

        }
        class BinaryExpression {
            - _binary_operator : BinaryOperator
            - _left_operand : std:unique_ptr<Expression>
            - _right_operand : std::unique_ptr<Expression>
        }
        ' Dependencies
        RValue <|-- PrimaryExpression
        RValue <|-- UnaryExpression
        RValue <|-- BinaryExpression
        enum BinaryOperator {
            .. Precedence: 9 ..
            DEREFERENCE : "^",
            .. Precedence: 8 ..
            NEGATION : "-",
            UNARY_PLUS : "+",
            COMPLEMENT : "NOT",
            .. Precedence: 7 ..
            EXPONENTIATION : "**",
            .. Precedence: 6 ..
            MULTIPLY : "*",
            DIVIDE : "/",
            MODULO : "MOD",
            .. Precedence: 5 ..
            ADD : "+",
            SUBTRACT : "-",
            .. Precedence: 4 ..
            GREATER_THAN : ">",
            LESS_THAN : "<",
            GREATER_THAN_OR_EQUAL_TO : ">=",
            LESS_THAN_OR_EQUAL_TO : "<=",
            EQUALITY : "=",
            INEQUALITY : "<>"
            .. Precedence: 3 ..
            BOOLEAN_AND : "&",
            BOOLEAN_AND : "AND",
            .. Precedence: 2 ..
            BOOLEAN_EXCLUSIVE_OR : "XOR",
            .. Precedence: 1 ..
            BOOLEAN_OR : "OR"
        }
        package "constant" {
            abstract class Constant {

            }
            class IntegerConstant {

            }
            ' Dependencies
            PrimaryExpression <|-- Constant
            Constant <|-- IntegerConstant
        }
        ' Dependencies
        BinaryExpression -- BinaryOperator
    }
    package "pou" {
        abstract class Pou {
            # Pou(std::string name)
        }

        class Program {
            - _environment : std::unique_ptr<Environment> const
            - _statements : std::vector<std::unique_ptr<Statement>> const
            + Program(std::string name)
        }

        class FunctionBlock {
            + FunctionBlock(std::string name)
        }

        ' Dependencies
        Pou <|-- FunctionBlock
    }
    class Project {

    }
    package "statement" {
        abstract class Statement {

        }
        class AssignmentStatement {
            - _variable_access : std::unique_ptr<VariableAccess>
            - _expression : std::unique_ptr<Expression>
        }
        abstract class SubprogramControlStatement {

        }
        class InvocationStatement {

        }
        abstract class SelectionStatement {

        }
        class IfStatement {

        }
        abstract class IterationStatement {

        }
        class WhileStatement {

        }
        abstract class StatementVisitor {
            + visit(AssignmentStatement &assignment_statement) : void
        }
        ' Dependencies
        Statement <|-- AssignmentStatement
        Statement <|-- SubprogramControlStatement
        SubprogramControlStatement <|-- InvocationStatement
        Statement <|-- SelectionStatement
        SelectionStatement <|-- IfStatement
        Statement <|-- IterationStatement
        IterationStatement <|-- WhileStatement
        Statement -- StatementVisitor
    }
    class StatementCompilePass {

    }
    package "instruction" {
        abstract class Instruction {

        }

        class AssignmentInstruction {

        }
        class CallInstruction {

        }
        class BranchInstruction {

        }
        ' Dependencies
        Instruction <|-- AssignmentInstruction
        Instruction <|-- CallInstruction
        Instruction <|-- BranchInstruction
    }
    class Cfg {

    }
    class BasicBlock {
        - _id : int
    }
    package "variable" {
        abstract class Variable {
            # Variable(std::string name, std::string type)
        }
    }
    ' The environment is a mapping from names to locations in the store.
    class Environment {
        - _name_to_type : std::unordered_map<std::string, std::unique_ptr<Type>>
        - _name_to_variable : std::unordered_map<std::string, std::unique_ptr<Variable>>
        + addType(std::unique_ptr<Type>)
        + addVariable(std::unique_ptr<Variable>)
    }
    class SSAFormConstructor {

    }
    package "ssa" {
        abstract class Value {

        }
        class SimpleDefinition {

        }
        class Phi {

        }
        ' Dependencies
        Value <|-- Phi
        Value <|-- SimpleDefinition
    }
    ' Dependencies
    Compiler <.. Program : <<created by>>
    Compiler -- SSAFormConstructor
    Program "1" *-- "1..*" Pou
    FunctionBlock "1" *-- "1..*" Pou
    Program "1" *-- "1" Environment
    Name <|-- Type
    Name <|-- Variable
    Name <|-- Program
    Variable "1" *-- "1" Type
    Type <|-- ElementaryType
    Type <|-- DerivedType
    DerivedType <|-- Pou
    Pou "1" *-- "0..*" Statement
    Pou "1" *-- "1" Environment
    Environment "1" *-- "0..*" Variable
    Cfg "1" *-- "2..*" BasicBlock
    StatementVisitor <|-- StatementCompilePass
    SSAFormConstructor -- Cfg
    SSAFormConstructor -- Value
    BasicBlock "1" *-- "0..*" Instruction
    BasicBlock "1" *-- "1..*" Value
}
@enduml